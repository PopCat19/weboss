// @ts-check
function init() {
    var myNumber = 42;
    myNumber = "Some text that is no number";

/*
*   object layering:
*       assuming number of possible hits doesn't exceed 9998
*/
// Define a module that depends on the following modules:
define(["osu", "playerActions", "SliderMesh", "overlay/score", "overlay/volume", "overlay/loading", "overlay/break", "overlay/progress", "overlay/hiterrormeter"],
    function(Osu, setPlayerActions, SliderMesh, ScoreOverlay, VolumeMenu, LoadingMenu, BreakOverlay, ProgressOverlay, ErrorMeterOverlay) {
        // Define a function to clamp a value between 0 and 1
        function clamp01(a) {
            // Return the minimum of 1 and the maximum of 0 and the input value
            return Math.min(1, Math.max(0, a));
        }
    
        // Define a function to linearly interpolate between two colors
        function colorLerp(rgb1, rgb2, t) {
            // Calculate the red, green, and blue components of the interpolated color
            let r = (1-t) * ((rgb1>>16)/255) + t * ((rgb2>>16)/255);
            let g = (1-t) * (((rgb1>>8)&255)/255) + t * (((rgb2>>8)&255)/255);
            let b = (1-t) * ((rgb1&255)/255) + t * ((rgb2&255)/255);
            // Return the interpolated color as a 32-bit integer
            return Math.round(r*255)<<16 | Math.round(g*255)<<8 | Math.round(b*255);
        }
    
        // Define a function to repeat a value within a range of 0 to 2
        function repeatclamp(a) {
            // Calculate the remainder of the input value divided by 2
            a%=2;
            // If the result is greater than 1, return 2 minus the result
            return a>1? 2-a: a;
        }
    
        // Define a Playback class
        function Playback(game, osu, track) {
            // Create a new instance of the Playback class
            var self = this;
            // Expose the instance to the global scope
            window.playback = this;
            // Initialize the game, osu, and track properties
            self.game = game;
            self.osu = osu;
            self.track = track;
            // Initialize the background property to null
            self.background = null;
            // Initialize the started property to false
            self.started = false;
            // Initialize the upcomingHits property to an empty array
            self.upcomingHits = [];
            // Create a copy of the hit objects in the track
            self.hits = [];
            _.each(self.track.hitObjects, function(o){
                // Create a new object for each hit object in the track
                self.hits.push(Object.assign({},o));
            });
            // Initialize the offset property to 0
            self.offset = 0;
            // Initialize the currentHitIndex property to 0
            self.currentHitIndex = 0; // index for all hit objects
            // Initialize the ended property to false
            self.ended = false;
            // Initialize the mods properties
            self.autoplay = game.autoplay;
            self.modhidden = game.hidden;
            self.playbackRate = 1.0;
            // Apply the nightcore and daycore mods to the playback rate
            if (self.game.nightcore) self.playbackRate *= 1.5;
            if (self.game.daycore) self.playbackRate *= 0.75;
            // Initialize the hideNumbers, hideGreat, and hideFollowPoints properties
            self.hideNumbers = game.hideNumbers;
            self.hideGreat = game.hideGreat;
            self.hideFollowPoints = game.hideFollowPoints;
    
            // Initialize the approachScale property to 3
            self.approachScale = 3;
            // Initialize the audioReady property to false
            self.audioReady = false;
            // Calculate the end time of the playback
            self.endTime = self.hits[self.hits.length-1].endTime + 1500;
            // Calculate the wait time before starting the playback
            this.wait = Math.max(0, 1500-this.hits[0].time);
            // Calculate the skip time for the playback
            self.skipTime = this.hits[0].time / 1000 - 3;
            // Initialize the skipped property to false
            self.skipped = false;
    
            // Define a callback function for when the osu instance is ready
            self.osu.onready = function() {
                // Hide the loading menu
                self.loadingMenu.hide();
                // Set the audioReady property to true
                self.audioReady = true;
                // Call the onload function if it exists
                if (self.onload)
                    self.onload();
                // Start the playback
                self.start();
            }
    
            // Define a load function to load the track
            self.load = function() {
                // Load the track using the osu instance
                self.osu.load_mp3(self.track);
            }
    
            // Create a new PIXI Container for the game field
            var gfx = window.gfx = {}; // game field area
            self.gamefield = new PIXI.Container();
            // Define a function to calculate the size of the game field
self.calcSize = function() {
    // Calculate the width and height of the game field
    gfx.width = game.window.innerWidth;
    gfx.height = game.window.innerHeight;

    // Ensure the aspect ratio of the game field is maintained
    if (gfx.width / 512 > gfx.height / 384) {
        gfx.width = gfx.height / 384 * 512;
    } else {
        gfx.height = gfx.width / 512 * 384;
    }

    // Scale the game field to 80% of the window size
    gfx.width *= 0.8;
    gfx.height *= 0.8;

    // Calculate the x and y offsets of the game field
    gfx.xoffset = (game.window.innerWidth - gfx.width) / 2;
    gfx.yoffset = (game.window.innerHeight - gfx.height) / 2;

    // Set the position and scale of the game field
    self.gamefield.x = gfx.xoffset;
    self.gamefield.y = gfx.yoffset;
    self.gamefield.scale.set(gfx.width / 512);
};

// Create a new LoadingMenu instance
self.loadingMenu = new LoadingMenu({
    width: game.window.innerWidth,
    height: game.window.innerHeight
}, track);

// Create a new VolumeMenu instance
self.volumeMenu = new VolumeMenu({
    width: game.window.innerWidth,
    height: game.window.innerHeight
});

// Create a new BreakOverlay instance
self.breakOverlay = new BreakOverlay({
    width: game.window.innerWidth,
    height: game.window.innerHeight
});

// Create a new ProgressOverlay instance
self.progressOverlay = new ProgressOverlay({
    width: game.window.innerWidth,
    height: game.window.innerHeight
}, this.hits.time - 1500, this.hits[this.hits.length - 1].endTime);

// Define a function to handle window resize events
window.onresize = function() {
    // Resize the renderer to match the new window size
    window.app.renderer.resize(window.innerWidth, window.innerHeight);
    // If the audio is ready, pause the playback
    if (self.audioReady) self.pause();
    // Recalculate the game field size
    self.calcSize();
    // Resize the score overlay
    self.scoreOverlay.resize({width: window.innerWidth, height: window.innerHeight});
    // Resize the error meter
    self.errorMeter.resize({width: window.innerWidth, height: window.innerHeight});
    // Resize the loading menu
    self.loadingMenu.resize({width: window.innerWidth, height: window.innerHeight});
    // Resize the volume menu
    self.volumeMenu.resize({width: window.innerWidth, height: window.innerHeight});
    // Resize the break overlay
    self.breakOverlay.resize({width: window.innerWidth, height: window.innerHeight});
    // Resize the progress overlay
    self.progressOverlay.resize({width: window.innerWidth, height: window.innerHeight});

    // If the background has a texture, update its position and scale
    if (self.background && self.background.texture) {
        self.background.x = window.innerWidth / 2;
        self.background.y = window.innerHeight / 2;
        self.background.scale.set(Math.max(window.innerWidth / self.background.texture.width, window.innerHeight / self.background.texture.height));
    }
   
    // Reset the transform of the slider mesh
    SliderMesh.prototype.resetTransform({
        dx: 2 * gfx.width / window.innerWidth / 512,
        ox: -1 + 2 * gfx.xoffset / window.innerWidth,
        dy: -2 * gfx.height / window.innerHeight / 384,
        oy: 1 - 2 * gfx.yoffset / window.innerHeight,
    });
}

// Define a function to handle window blur events
var blurCallback = function(e){
    // If the audio is ready, pause the playback
    if (self.audioReady)
        self.pause();
};
// Add the blur callback to the window
window.addEventListener("blur", blurCallback);

// Deal with difficulties
this.OD = track.difficulty.OverallDifficulty;
this.CS = track.difficulty.CircleSize;
this.AR = track.difficulty.ApproachRate;
this.HP = track.difficulty.HPDrainRate;
// Apply the hardrock mod to the difficulties
if (game.hardrock) {
    this.OD = Math.min(this.OD * 1.4, 10);
    this.CS = Math.min(this.CS * 1.3, 10);
    this.AR = Math.min(this.AR * 1.4, 10);
    this.HP = Math.min(this.HP * 1.4, 10);
}
// Apply the easy mod to the difficulties
if (game.easy) {
    this.OD = this.OD * 0.5;
    this.CS = this.CS * 0.5;
    this.AR = this.AR * 0.5;
    this.HP = this.HP * 0.5;
}

// Calculate the score mod multiplier
let scoreModMultiplier = 1.0;
// Apply the easy mod to the score mod multiplier
if (game.easy) scoreModMultiplier *= 0.50;
// Apply the daycore mod to the score mod multiplier
if (game.daycore) scoreModMultiplier *= 0.30;
// Apply the hardrock mod to the score mod multiplier
if (game.hardrock) scoreModMultiplier *= 1.06;
// Apply the nightcore mod to the score mod multiplier
if (game.nightcore) scoreModMultiplier *= 1.12;
// Apply the hidden mod to the score mod multiplier
if (game.hidden) scoreModMultiplier *= 1.06;

// Create a new ScoreOverlay instance
self.scoreOverlay = new ScoreOverlay({width: game.window.innerWidth, height: game.window.innerHeight}, this.HP, scoreModMultiplier);
// Calculate the circle radius
self.circleRadius = (109 - 9 * this.CS)/2; // unit: osu pixel
// Calculate the hit sprite scale
self.hitSpriteScale = self.circleRadius / 60;
// Calculate the Meh, Good, and Great times
self.MehTime = 200 - 10 * this.OD;
self.GoodTime = 140 - 8 * this.OD;
self.GreatTime = 80 - 6 * this.OD;
// Create a new ErrorMeterOverlay instance
self.errorMeter = new ErrorMeterOverlay({width: game.window.innerWidth, height: game.window.innerHeight}, this.GreatTime, this.GoodTime, this.MehTime);
// Calculate the approach time
self.approachTime = this.AR<5? 1800-120*this.AR: 1950-150*this.AR; // time of sliders/hitcircles and approach circles approaching
// Calculate the approach fade-in time
self.approachFadeInTime = Math.min(800, self.approachTime); // duration of approach circles fading in, at beginning of approaching
// Update the hit objects with the modhidden mod
for (let i=0; i<self.hits.length; ++i) {
    let hit = self.hits[i];
    // If the modhidden mod is enabled and this is not the first hit object
    if (self.modhidden && (i>0 && self.hits[i-1].type != "spinner")) { 
        // Update the object fade-in time and fade-out offset
        hit.objectFadeInTime = 0.4 * self.approachTime;
        hit.objectFadeOutOffset = -0.6 * self.approachTime;
        hit.circleFadeOutTime = 0.3 * self.approachTime;
    }
    else {
        // Enable flashing for this hit object
        hit.enableflash = true;
        // Update the object fade-in time and fade-out offset
        hit.objectFadeInTime = Math.min(400, self.approachTime); // duration of sliders/hitcircles fading in, at beginning of approaching
        hit.circleFadeOutTime = 100;
        hit.objectFadeOutOffset = self.MehTime;
    }
}
// Update the slider hit objects with the modhidden mod
for (let i=0; i<self.hits.length; ++i) {
    if (self.hits[i].type == "slider") {
        // If the modhidden mod is enabled and this is not the first hit object
        if (self.modhidden && (i>0 && self.hits[i-1].type != "spinner")) {
            // Update the fade-out offset and duration
            self.hits[i].fadeOutOffset = -0.6 * self.approachTime;
            self.hits[i].fadeOutDuration = self.hits[i].sliderTimeTotal - self.hits[i].fadeOutOffset;
        }
        else {
            // Update the fade-out offset and duration
            self.hits[i].fadeOutOffset = self.hits[i].sliderTimeTotal;
            self.hits[i].fadeOutDuration = 300;
        }
    }
}

// Define various timing constants
self.glowFadeOutTime = 350;
self.glowMaxOpacity = 0.5;
self.flashFadeInTime = 40;
self.flashFadeOutTime = 120;
self.flashMaxOpacity = 0.8;
self.scoreFadeOutTime = 500;
self.followZoomInTime = 100;
self.followFadeOutTime = 100;
self.ballFadeOutTime = 100;
self.objectDespawnTime = 1500;
self.backgroundFadeTime = 800;
self.spinnerAppearTime = self.approachTime;
self.spinnerZoomInTime = 300;
self.spinnerFadeOutTime = 150;

// Set up player actions
setPlayerActions(self);

// Set the game's paused state to false
self.game.paused = false;

// Define a function to pause the game
this.pause = function() {
    // If the audio can be paused, set the game's paused state to true
    if (this.osu.audio.pause()) { 
        this.game.paused = true;
        // Get the pause menu element
        let menu = document.getElementById("pause-menu");
        // Remove the hidden attribute from the pause menu
        menu.removeAttribute("hidden");
        // Get the continue, retry, and quit buttons
        btn_continue = document.getElementById("pausebtn-continue");
        btn_retry = document.getElementById("pausebtn-retry");
        btn_quit = document.getElementById("pausebtn-quit");
        // Set up the button click handlers
        btn_continue.onclick = function() {
            // Resume the game when the continue button is clicked
            self.resume();
            // Remove the button click handlers
            btn_continue.onclick = null;
            btn_retry.onclick = null;
            btn_quit.onclick = null;
        }
        btn_retry.onclick = function() {
            // Set the game's paused state to false when the retry button is clicked
            self.game.paused = false;
            // Hide the pause menu
            menu.setAttribute("hidden","");
            // Retry the game
            self.retry();
        }
        btn_quit.onclick = function() {
            // Set the game's paused state to false when the quit button is clicked
            self.game.paused = false;
            // Hide the pause menu
            menu.setAttribute("hidden","");
            // Quit the game
            self.quit();
        }
    }
};

// Define a function to resume the game
this.resume = function() {
    // Play the audio
    this.osu.audio.play();
    // Set the game's paused state to false
    this.game.paused = false;
    // Hide the pause menu
    document.getElementById("pause-menu").setAttribute("hidden","");
};

// Adjust the volume using the mouse wheel
var wheelCallback;
if (game.allowMouseScroll) {
    wheelCallback = function(e) {
        // Adjust the master volume based on the mouse wheel delta
        self.game.masterVolume -= e.deltaY * 0.002;
        // Ensure the master volume is within the valid range
        if (self.game.masterVolume < 0) {
            self.game.masterVolume = 0;
        } 
        if (self.game.masterVolume > 1) {
            self.game.masterVolume = 1;
        }
        // Update the audio gain
        self.osu.audio.gain.gain.value = self.game.musicVolume * self.game.masterVolume;
        // Update the volume menu
        self.volumeMenu.setVolume(self.game.masterVolume * 100);
    };
    // Add the wheel callback to the window
    window.addEventListener('wheel', wheelCallback);
}

// Define a function to handle pause key presses
var pauseKeyCallback = function(e) {
    // If the escape key is pressed and the game is not paused, pause the game
    if ((e.keyCode === game.ESCkeycode || e.keyCode == game.ESC2keycode) && !self.game.paused) {
        self.pause();
        self.pausing = true; // to prevent resuming at end of first key press
    }
};

// Define a function to handle resume key presses
var resumeKeyCallback = function(e) {
    // If the escape key is pressed and the game is paused, resume the game
    if ((e.keyCode === game.ESCkeycode || e.keyCode == game.ESC2keycode) && self.game.paused) {
        if (self.pausing)
            self.pausing = false;
        else
            self.resume();
    }
};

// Define a function to handle skip key presses
var skipKeyCallback = function(e) {
    // If the control key is pressed and the game is not paused, skip the current song
    if (e.keyCode === game.CTRLkeycode && !self.game.paused) {
        if (!self.skipped && !self.pausing)
            self.skip();
    }
}

// Add the key press callbacks to the window
window.addEventListener("keydown", pauseKeyCallback);
window.addEventListener("keyup", resumeKeyCallback);
window.addEventListener("keydown", skipKeyCallback);

// Define an easing function for fading out
this.fadeOutEasing = function(t) { // [0..1] -> [1..0]
    if (t <= 0) return 1;
    if (t > 1) return 0;
    return 1 - Math.sin(t * Math.PI/2);
}

// Define a function to get the judgement text for a given score
function judgementText(points) {
    switch (points) {
        case 0: return "miss";
        case 50: return "meh";
        case 100: return "good";
        case 300: return "great";
        default: throw "no such judgement";
    }
}

// Define a function to get the judgement color for a given score
function judgementColor(points) {
    switch (points) {
        case 0: return 0xed1121;
        case 50: return 0xffcc22;
        case 100: return 0x88b300;
        case 300: return 0x66ccff;
        default: throw "no such judgement";
    }
}

// Define a function to create a judgement text object
this.createJudgement = function(x, y, depth, finalTime) {
    let judge = new PIXI.BitmapText('', {font: {name: 'Venera', size: 20}});
    judge.anchor.set(0.5);
    judge.scale.set(0.85 * this.hitSpriteScale, 1 * this.hitSpriteScale);
    judge.visible = false;
    judge.basex = judge.x = x;
    judge.basey = judge.y = y;
    judge.depth = depth;
    judge.points = -1;
    judge.finalTime = finalTime;
    judge.defaultScore = 0;
    return judge;
}

// Define a function to invoke a judgement
this.invokeJudgement = function(judge, points, time) {
    judge.visible = true;
    judge.points = points;
    judge.t0 = time;
    if (!this.hideGreat || points!=300)
        judge.text = judgementText(points);
    judge.tint = judgementColor(points);
    this.updateJudgement(judge, time);
}

// Define a function to update a judgement
this.updateJudgement = function(judge, time) // set transform of judgement text
{
    if (judge.points < 0 && time >= judge.finalTime) // miss
    {
        this.scoreOverlay.hit(judge.defaultScore, 300, time);
        this.invokeJudgement(judge, judge.defaultScore, time);
        return;
    }
    if (!judge.visible) return;

    let t = time - judge.t0;

    if (judge.points == 0) // miss
    {
        if (t > 800) {
            judge.visible = false;
            return;
        }
        judge.alpha = (t<100)? t/100: (t<600)? 1: 1-(t-600)/200;
        judge.y = judge.basey + 100 * Math.pow(t/800, 5) * this.hitSpriteScale;
        judge.rotation = 0.7 * Math.pow(t/800, 5);
    }
    else // meh, good, great
    {
        if (t > 500) {
            judge.visible = false;
            return;
        }
        judge.alpha = (t<100)? t/100: 1-(t-100)/400;
        judge.letterSpacing = 70 *(Math.pow(t/1800-1,5)+1);
    }
}

// Define a function to create a background
this.createBackground = function(){
    // Load background if possible
    function loadBackground(uri) {
        var loader = new PIXI.Loader();
        loader.add("bg", uri, {loadType: PIXI.LoaderResource.LOAD_TYPE.IMAGE}).load(function(loader, resources) {
            let sprite = new PIXI.Sprite(resources.bg.texture);
            // apply gaussian blur if enabled
            if (self.game.backgroundBlurRate > 0.0001) {
                let width = resources.bg.texture.width;
                let height = resources.bg.texture.height;
                sprite.anchor.set(0.5);
                sprite.x = width/2;
                sprite.y = height/2;
                let blurstrength = self.game.backgroundBlurRate * Math.min(width, height);
                t = Math.max(Math.min(width, height), Math.max(10,blurstrength)*3);
                // zoom in the image a little bit to hide the dark edges
                // (since filter clamping somehow doesn't work here)
                sprite.scale.set(t/(t-2*Math.max(10,blurstrength)));
                let blurFilter = new PIXI.filters.BlurFilter(blurstrength,14);
                blurFilter.autoFit = false;
                sprite.filters = [blurFilter];
            }
            let texture = PIXI.RenderTexture.create(resources.bg.texture.width, resources.bg.texture.height);
            window.app.renderer.render(sprite, texture);

            self.background = new PIXI.Sprite(texture);
            self.background.anchor.set(0.5);
            self.background.x = window.innerWidth/2;
            self.background.y = window.innerHeight/2;
            // fit the background (preserve aspect)
            self.background.scale.set(Math.max(window.innerWidth / self.background.texture.width, window.innerHeight / self.background.texture.height));
            self.game.stage.addChildAt(self.background, 0);
        });
    }

    // Check if the track has events
if (self.track.events.length != 0) {
    // Get the file name of the background image
    var file = self.track.events[0][2];
    // If the first event is a video, get the file name of the next event
    if (track.events[0][0] === "Video") {
        file = self.track.events[1][2];
    }
    // Remove the quotes from the file name
    file = file.substr(1, file.length - 2);
    // Get the entry for the background image from the zip file
    entry = osu.zip.getChildByName(file);
    // If the entry exists, load the background image
    if (entry) {
        entry.getBlob("image/jpeg", function (blob) {
            // Create a URL for the background image
            var uri = URL.createObjectURL(blob);
            // Load the background image
            loadBackground(uri);
        });
    } else {
        // If the entry does not exist, load the default background image
        loadBackground("skin/defaultbg.jpg");
    }
} else {
    // If the track does not have events, load the default background image
    loadBackground("skin/defaultbg.jpg");
}

// Create the background
self.createBackground();

// Load the combo colors
function convertcolor(color) {
    // Convert the color to a hexadecimal value
    return ((+color[0]) << 16) | ((+color[1]) << 8) | ((+color[2]) << 0);
}
var combos = [];
// Convert each color in the track's colors array to a hexadecimal value
for (var i = 0; i < track.colors.length; i++) {
    combos.push(convertcolor(track.colors[i]));
}
// Get the slider track override and border colors
var SliderTrackOverride;
var SliderBorder;
if (track.colors.SliderTrackOverride)
    SliderTrackOverride = convertcolor(track.colors.SliderTrackOverride);
if (track.colors.SliderBorder)
    SliderBorder = convertcolor(track.colors.SliderBorder);

// Add the game field, score overlay, error meter, progress overlay, break overlay, volume menu, and loading menu to the stage
self.game.stage.addChild(this.gamefield);
self.game.stage.addChild(this.scoreOverlay);
self.game.stage.addChild(this.errorMeter);
self.game.stage.addChild(this.progressOverlay);
self.game.stage.addChild(this.breakOverlay);
self.game.stage.addChild(this.volumeMenu);
self.game.stage.addChild(this.loadingMenu);

// Define a function to create a hit circle
this.createHitCircle = function(hit) {
    // Create a new hit sprite
    function newHitSprite(spritename, depth, scalemul = 1, anchorx = 0.5, anchory = 0.5) {
        // Create a new sprite
        let sprite = new PIXI.Sprite(Skin[spritename]);
        // Set the sprite's initial scale
        sprite.initialscale = self.hitSpriteScale * scalemul;
        // Set the sprite's scale
        sprite.scale.x = sprite.scale.y = sprite.initialscale;
        // Set the sprite's anchor
        sprite.anchor.x = anchorx;
        sprite.anchor.y = anchory;
        // Set the sprite's position
        sprite.x = hit.x;
        sprite.y = hit.y;
        // Set the sprite's depth
        sprite.depth = depth;
        // Set the sprite's alpha
        sprite.alpha = 0;
        // Add the sprite to the hit object's objects array
        hit.objects.push(sprite);
        // Return the sprite
        return sprite;
    }
    // Create the hit circle's base
    let index = hit.index + 1;
    let basedep = 4.9999 - 0.0001 * hit.hitIndex;
    hit.base = newHitSprite("disc.png", basedep, 0.5);
    // Set the hit circle's base tint
    hit.base.tint = combos[hit.combo % combos.length];
    // Create the hit circle's circle
    hit.circle = newHitSprite("hitcircleoverlay.png", basedep, 0.5);
    // Create the hit circle's glow
    hit.glow = newHitSprite("ring-glow.png", basedep+2, 0.46);
    // Set the hit circle's glow tint
    hit.glow.tint = combos[hit.combo % combos.length];
    // Set the hit circle's glow blend mode
    hit.glow.blendMode = PIXI.BLEND_MODES.ADD;
    // Create the hit circle's burst
    hit.burst = newHitSprite("hitburst.png", 8.00005 + 0.0001 * hit.hitIndex);
    // Set the hit circle's burst visibility
    hit.burst.visible = false;
    // Create the hit circle's approach circle
    hit.approach = newHitSprite("approachcircle.png", 8 + 0.0001 * hit.hitIndex);
    // Set the hit circle's approach circle tint
    hit.approach.tint = combos[hit.combo % combos.length];
    // Create the hit circle's judgement
    hit.judgements.push(this.createJudgement(hit.x, hit.y, 4, hit.time + this.MehTime));
    // Create the hit circle's combo numbers
    hit.numbers = [];
    if (index <= 9) {
        // Create a single digit combo number
        hit.numbers.push(newHitSprite("score-"+index+".png", basedep, 0.4, 0.5, 0.47));
    } else if (index <= 99) {
        // Create a two digit combo number
        hit.numbers.push(newHitSprite("score-"+(index%10)+".png", basedep, 0.35, 0, 0.47));
        hit.numbers.push(newHitSprite("score-"+((index-(index%10))/10)+".png", basedep, 0.35, 1, 0.47));
    }
    // Note: combos > 99 hits are unsupported
}

// Define a function to create a slider
this.createSlider = function(hit) {
    // Initialize the slider's last repeat and next tick
    hit.lastrep = 0; 
    hit.nexttick = 0; 
    // Create the slider body
    var body = hit.body = new SliderMesh(hit.curve, this.circleRadius, hit.combo % combos.length);
    // Set the slider body's alpha
    body.alpha = 0;
    // Set the slider body's depth
    body.depth = 4.9999-0.0001*hit.hitIndex;
    // Add the slider body to the hit object's objects array
    hit.objects.push(body);
    // Define a function to create a new sprite
    function newSprite(spritename, x, y, scalemul = 1) {
        // Create a new sprite
        let sprite = new PIXI.Sprite(Skin[spritename]);
        // Set the sprite's scale
        sprite.scale.set(self.hitSpriteScale * scalemul);
        // Set the sprite's anchor
        sprite.anchor.set(0.5);
        // Set the sprite's position
        sprite.x = x;
        sprite.y = y;
        // Set the sprite's depth
        sprite.depth = 4.9999-0.0001*hit.hitIndex;
        // Set the sprite's alpha
        sprite.alpha = 0;
        // Add the sprite to the hit object's objects array
        hit.objects.push(sprite);
        // Return the sprite
        return sprite;
    }
    // Create the slider's ticks
    hit.ticks = [];
    let tickDuration = hit.timing.trueMillisecondsPerBeat / this.track.difficulty.SliderTickRate;
    let nticks = Math.floor(hit.sliderTimeTotal / tickDuration) + 1;
    for (let i=0; i<nticks; ++i) {
        let t = hit.time + i * tickDuration;
        // Calculate the position of the tick
        let pos = repeatclamp(i * tickDuration / hit.sliderTime);
        if (Math.min(pos,1-pos) * hit.sliderTime <= 10) // omit ticks near slider end (within 10ms)
            continue;
        let at = hit.curve.pointAt(pos);
        // Create the tick sprite
        hit.ticks.push(newSprite("sliderscorepoint.png", at.x, at.y));
        // Set the tick's appear time
        hit.ticks[hit.ticks.length-1].appeartime = t - 2 * tickDuration;
        // Set the tick's time
        hit.ticks[hit.ticks.length-1].time = t;
        // Set the tick's result
        hit.ticks[hit.ticks.length-1].result = false;
    }
    // Create the slider's reverse symbol
    if (hit.repeat > 1) {
        // Calculate the position of the reverse symbol
        let p = hit.curve.curve[hit.curve.curve.length-1];
        let p2 = hit.curve.curve[hit.curve.curve.length-2];
        // Create the reverse symbol sprite
        hit.reverse = newSprite("reversearrow.png", p.x, p.y, 0.36);
        // Set the reverse symbol's rotation
        hit.reverse.rotation = Math.atan2(p2.y - p.y, p2.x - p.x);
    }
    if (hit.repeat > 2) {
        // Calculate the position of the reverse symbol
        let p = hit.curve.curve[0];
        let p2 = hit.curve.curve[1];
        // Create the reverse symbol sprite
        hit.reverse_b = newSprite("reversearrow.png", p.x, p.y, 0.36);
        // Set the reverse symbol's rotation
        hit.reverse_b.rotation = Math.atan2(p2.y - p.y, p2.x - p.x);
        // Set the reverse symbol's visibility
        hit.reverse_b.visible = false; // Only visible when it's the next end to hit
    }
    // Create the slider's follow circle
    hit.follow = newSprite("sliderfollowcircle.png", hit.x, hit.y);
    // Set the follow circle's visibility
    hit.follow.visible = false;
    // Set the follow circle's blend mode
    hit.follow.blendMode = PIXI.BLEND_MODES.ADD;
    // Set the follow circle's size
    hit.followSize = 1; // [1,2] current follow circle size relative to hitcircle
    // Create the slider's ball
    hit.ball = newSprite("sliderb.png", hit.x, hit.y, 0.5);
    // Set the ball's visibility
    hit.ball.visible = false;
    // Create the slider's judgement
    self.createHitCircle(hit);
    // Create the slider's judgement at the end
    let endPoint = hit.curve.curve[hit.curve.curve.length-1];
    for (let i=1; i<=hit.repeat; ++i) {
        let x = (i%2==1)? endPoint.x: hit.x;
        let y = (i%2==1)? endPoint.y: hit.y;
        hit.judgements.push(this.createJudgement(x, y, 4, hit.time + i * hit.sliderTime));
    }
}

// Define a function to create a spinner
this.createSpinner = function(hit) {
    // Set the spinner's approach time
    hit.approachTime = self.spinnerAppearTime + self.spinnerZoomInTime;
    // Set the spinner's position
    hit.x = 512/2;
    hit.y = 384/2;
    // Set the spinner's rotation
    hit.rotation = 0;
    // Set the spinner's rotation progress
    hit.rotationProgress = 0;
    // Set the spinner's clicked state
    hit.clicked = false;
    // Calculate the required rotation per second
    let spinRequiredPerSec = this.OD<5? 3+0.4*this.OD: 2.5+0.5*this.OD;
    spinRequiredPerSec *= 0.7; // make it easier
    // Set the spinner's required rotation
    hit.rotationRequired = 2 * Math.PI * spinRequiredPerSec * (hit.endTime - hit.time)/1000;
    // Define a function to create a new sprite
    function newsprite(spritename) {
        // Create a new sprite
        var sprite = new PIXI.Sprite(Skin[spritename]);
        // Set the sprite's anchor
        sprite.anchor.set(0.5);
        // Set the sprite's position
        sprite.x = hit.x;
        sprite.y = hit.y;
        // Set the sprite's depth
        sprite.depth = 4.9999 - 0.0001 * (hit.hitIndex || 1);
        // Set the sprite's alpha
        sprite.alpha = 0;
        // Add the sprite to the hit object's objects array
        hit.objects.push(sprite);
        // Return the sprite
        return sprite;
    }
    // Create the spinner's base
hit.base = newsprite("spinnerbase.png");
// Create the spinner's progress
hit.progress = newsprite("spinnerprogress.png");
// Create the spinner's top
hit.top = newsprite("spinnertop.png");
// If the modhidden mod is enabled, hide the progress and base
if (this.modhidden) {
    hit.progress.visible = false;
    hit.base.visible = false;
}
// Create the spinner's judgement
hit.judgements.push(this.createJudgement(hit.x, hit.y, 4, hit.endTime + 233));

// Define a function to create a follow point connection between two hit objects
this.createFollowPoint = function(hitBefore, hit) {
    // Calculate the position and time of the follow point
    var x1 = hitBefore.x;
    var y1 = hitBefore.y;
    var t1 = hitBefore.time;
    if (hitBefore.type == "slider") {
        t1 += hitBefore.sliderTimeTotal;
        if (hitBefore.repeat % 2 == 1) {
            x1 = hitBefore.curve.curve[hitBefore.curve.curve.length-1].x;
            y1 = hitBefore.curve.curve[hitBefore.curve.curve.length-1].y;
        }
    }
    // Create a new container for the follow point
    var container = new PIXI.Container();
    container.depth = 3;
    container.x1 = x1;
    container.y1 = y1;
    container.t1 = t1;
    container.dx = hit.x - x1;
    container.dy = hit.y - y1;
    container.dt = hit.time - t1;
    container.preempt = this.approachTime;
    container.hit = hit;
    // Add the container to the hit object's objects array
    hit.objects.push(container);
    // Set the hit object's follow points to the container
    hit.followPoints = container;

    // Calculate the spacing and rotation of the follow points
    const spacing = this.circleRadius * 0.7;
    const rotation = Math.atan2(container.dy, container.dx);
    const distance = Math.hypot(container.dx, container.dy);
    // Create the follow points
    for (let d = spacing * 2; d < distance - 1.5 * spacing; d += spacing)
    {
        let p = new PIXI.Sprite(Skin["followpoint.png"]);
        p.scale.set(this.hitSpriteScale*0.3);
        p.x = x1 + container.dx * d/distance;
        p.y = y1 + container.dy * d/distance;
        p.blendMode = PIXI.BLEND_MODES.ADD;
        p.rotation = rotation;
        p.anchor.set(0.5);
        p.alpha = 0;
        p.fraction = d / distance; // store for convenience
        // Add the follow point to the container
        container.addChild(p);
    }
}

// Define a function to populate a hit object with PIXI objects
this.populateHit = function(hit) {
    // Increment the current hit index
    this.currentHitIndex += 1;
    // Set the hit object's hit index
    hit.hitIndex = this.currentHitIndex;
    // Initialize the hit object's objects and judgements arrays
    hit.objects = [];
    hit.judgements = [];
    // Initialize the hit object's score
    hit.score = -1;
    // Create the hit object's PIXI objects based on its type
    switch (hit.type) {
        case "circle":
            self.createHitCircle(hit);
            break;
        case "slider":
            self.createSlider(hit);
            break;
        case "spinner":
            self.createSpinner(hit);
            break;
    }
}

// Define a function to update the cursor predict visualizer
this.updateCursorPredictVisualizer = function() {
    // If the predict visualizer does not exist and mouse input is enabled, create it
    if (!this.predictVisualizer && game.mouse) {
        // Create a new sprite for the predict visualizer
        let o = this.predictVisualizer = new PIXI.Sprite(Skin["sliderb.png"]);
        o.anchor.set(0.5);
        o.tint = 0x00ff00;
        // Add the predict visualizer to the game field
        this.gamefield.addChild(o);
    }
    // If the predict visualizer exists, update its position and scale
    if (this.predictVisualizer) {
        // Get the prediction result from the mouse input
        let res = game.mouse(new Date().getTime()); // prediction result
        // Update the predict visualizer's position and scale
        this.predictVisualizer.x = res.x;
        this.predictVisualizer.y = res.y;
        this.predictVisualizer.scale.set(res.r/120);
        // Bring the predict visualizer to the front
        this.predictVisualizer.bringToFront();
    }
}

// Initialize the slider mesh with the combos, circle radius, and other parameters
SliderMesh.prototype.initialize(combos, this.circleRadius, {
    dx: 2 * gfx.width / window.innerWidth / 512,
    ox: -1 + 2 * gfx.xoffset / window.innerWidth,
    dy: -2 * gfx.height / window.innerHeight / 384,
    oy: 1 - 2 * gfx.yoffset / window.innerHeight,
}, SliderTrackOverride, SliderBorder); // prepare sliders

// Populate each hit object with PIXI objects
for (let i = 0; i < this.hits.length; i++) {
    this.populateHit(this.hits[i]); // Prepare sprites and such
}

// If the modhidden mod is enabled, hide the approach circles for hit objects
if (this.modhidden) {
    for (let i=0; i < this.hits.length; i++) {
        if (this.hits[i].approach && (i>0 && this.hits[i-1].type != "spinner"))
            this.hits[i].approach.visible = false;
    }
}

// If the hideNumbers mod is enabled, hide the combo numbers for hit objects
if (this.hideNumbers) {
    for (let i=0; i < this.hits.length; i++) {
        if (this.hits[i].numbers) {
            for (let j=0; j<this.hits[i].numbers.length; ++j)
                this.hits[i].numbers[j].visible = false;
        }
    }
}

// Create follow point connections between hit objects
for (let i=0; i<this.hits.length-1; i++) {
    if (this.hits[i].type != "spinner" && this.hits[i+1].type != "spinner" && this.hits[i+1].combo == this.hits[i].combo)
        this.createFollowPoint(this.hits[i], this.hits[i+1]);
}

// If the hideFollowPoints mod is enabled, hide the follow points for hit objects
if (this.hideFollowPoints) {
    for (let i=0; i < this.hits.length; i++) {
        if (this.hits[i].followPoints) {
            this.hits[i].followPoints.visible = false;
        }
    }
}

// Define a function to play a tick sound
this.playTicksound = function playTicksound(hit, time) {
    // Update the current timing index
    while (this.curtimingid+1 < this.track.timingPoints.length && this.track.timingPoints[this.curtimingid+1].offset <= time)
        this.curtimingid++;
    while (this.curtimingid>0 && this.track.timingPoints[this.curtimingid].offset > time)
        this.curtimingid--;
    // Get the current timing point
    let timing = this.track.timingPoints[this.curtimingid];
    // Calculate the volume of the tick sound
    let volume = self.game.masterVolume * self.game.effectVolume * (hit.hitSample.volume || timing.volume) / 100;
    // Play the tick sound
    self.game.sample[timing.sampleSet || self.game.sampleSet].slidertick.volume = volume;
    self.game.sample[timing.sampleSet || self.game.sampleSet].slidertick.play();
};

// Define a function to play a hit sound
this.playHitsound = function playHitsound(hit, id, time) {
    // Update the current timing index
    while (this.curtimingid+1 < this.track.timingPoints.length && this.track.timingPoints[this.curtimingid+1].offset <= time)
        this.curtimingid++;
    while (this.curtimingid>0 && this.track.timingPoints[this.curtimingid].offset > time)
        this.curtimingid--;
    // Get the current timing point
    let timing = this.track.timingPoints[this.curtimingid];
    // Calculate the volume of the hit sound
    let volume = self.game.masterVolume * self.game.effectVolume * (hit.hitSample.volume || timing.volume) / 100;
    // Play the hit sound
    function playHit(bitmask, normalSet, additionSet) {
        // The normal sound is always played
        self.game.sample[normalSet].hitnormal.volume = volume;
        self.game.sample[normalSet].hitnormal.play();
        if (bitmask & 2) {
            self.game.sample[additionSet].hitwhistle.volume = volume;
            self.game.sample[additionSet].hitwhistle.play();
        }
        if (bitmask & 4) {
            self.game.sample[additionSet].hitfinish.volume = volume;
            self.game.sample[additionSet].hitfinish.play();
        }
        if (bitmask & 8) {
            self.game.sample[additionSet].hitclap.volume = volume;
            self.game.sample[additionSet].hitclap.play();
        }
    }
    if (hit.type == 'circle' || hit.type == 'spinner') {
        let toplay = hit.hitSound;
        let normalSet = hit.hitSample.normalSet || timing.sampleSet || self.game.sampleSet;
        let additionSet = hit.hitSample.additionSet || normalSet;
        playHit(toplay, normalSet, additionSet);
    }
    if (hit.type == 'slider') {
        let toplay = hit.edgeHitsounds[id];
        let normalSet = hit.edgeSets[id].normalSet || timing.sampleSet || self.game.sampleSet;
        let additionSet = hit.edgeSets[id].additionSet || normalSet;
        playHit(toplay, normalSet, additionSet);
    }
};

// Define a function to handle a successful hit
this.hitSuccess = function hitSuccess(hit, points, time){
    // Update the score overlay
    this.scoreOverlay.hit(points, 300, time);
    // If the hit is successful, play a hit sound
    if (points > 0) {
        if (hit.type == "spinner")
            self.playHitsound(hit, 0, hit.endTime); // hit happen at end of spinner
        else {
            self.playHitsound(hit, 0, hit.time);
            self.errorMeter.hit(time - hit.time, time);
        }
        // Special rule: only missing slider end will not result in a miss
        if (hit.type == "slider") {
            hit.judgements[hit.judgements.length-1].defaultScore = 50;
        }
    }
    // Update the hit object's score and click time
    hit.score = points;
    hit.clickTime = time;
    // Invoke the judgement for the hit object
    self.invokeJudgement(hit.judgements[0], points, time);
};

// Define a function to update the upcoming hit objects
this.updateUpcoming = function(time) {
    // Update the waiting hit ID to the first object that has not ended
    while (waitinghitid < self.hits.length && self.hits[waitinghitid].endTime < time)
        waitinghitid++;
    // Define a function to find the index of the first child with a depth greater than or equal to a given value
    function findindex(i) { 
        let l = 0, r = self.gamefield.children.length;
        while (l+1<r) {
            let m = Math.floor((l+r)/2)-1;
            if ((self.gamefield.children[m].depth || 0) < i)
                l = m+1;
            else
                r = m+1;
        }
        return l;
    }
    // Cache hit objects in the next 3 seconds
    while (current < self.hits.length && futuremost < time + 3000) {
        var hit = self.hits[current++];
        // Add the hit object's judgements and objects to the game field
        for (let i = hit.judgements.length - 1; i >= 0; i--) {
            self.gamefield.addChildAt(hit.judgements[i], findindex(hit.judgements[i].depth || 0.0001));
        }
        for (let i = hit.objects.length - 1; i >= 0; i--) {
            self.gamefield.addChildAt(hit.objects[i], findindex(hit.objects[i].depth || 0.0001));
        }
        // Add the hit object to the upcoming hits array
        self.upcomingHits.push(hit);
        // Update the future most time
        if (hit.time > futuremost) {
            futuremost = hit.time;
        }
    }
    // Remove hit objects that have ended from the upcoming hits array
    for (var i = 0; i < self.upcomingHits.length; i++) {
        var hit = self.upcomingHits[i];
        var diff = hit.time - time;
        var despawn = -this.objectDespawnTime;
        if (hit.type === "slider") {
            despawn -= hit.sliderTimeTotal;
        }
        if (hit.type === "spinner") {
            despawn -= hit.endTime - hit.time;
        }
        if (diff < despawn) {
            self.upcomingHits.splice(i, 1);
            i--;
            // Remove the hit object's judgements and objects from the game field
            _.each(hit.objects, function(o) { self.gamefield.removeChild(o); o.destroy(); });
            _.each(hit.judgements, function(o) { self.gamefield.removeChild(o); o.destroy(); });
            // Mark the hit object as destroyed
            hit.destroyed = true;
        }
    }
}

// Define a function to update a follow point connection
this.updateFollowPoints = function(f, time) {
    // Update the position and alpha of each follow point
    for (let i=0; i<f.children.length; ++i)
    {
        let o = f.children[i];
        let startx = f.x1 + (o.fraction - 0.1) * f.dx;
        let starty = f.y1 + (o.fraction - 0.1) * f.dy;
        let endx = f.x1 + o.fraction * f.dx;
        let endy = f.y1 + o.fraction * f.dy;
        let fadeOutTime = f.t1 + o.fraction * f.dt;
        let fadeInTime = fadeOutTime - f.preempt;
        let relpos = clamp01((time-fadeInTime) / f.hit.objectFadeInTime);
        relpos *= 2-relpos; // ease out
        o.x = startx + (endx - startx) * relpos;
        o.y = starty + (endy - starty) * relpos;
        o.alpha = 0.5 * ((time<fadeOutTime)? clamp01((time-fadeInTime) / f.hit.objectFadeInTime): 1-clamp01((time-fadeOutTime) / f.hit.objectFadeInTime));
    }
}

// Define a function to update a hit circle
this.updateHitCircle = function(hit, time) {
    // Update the follow points if they exist
    if (hit.followPoints)
        this.updateFollowPoints(hit.followPoints, time);
    // Calculate the difference between the current time and the hit time
    let diff = hit.time - time; 
    // Update the approach circle
    let approachFullAppear = this.approachTime - this.approachFadeInTime; 
    if (diff <= this.approachTime && diff > 0) { 
        let scalemul = diff / this.approachTime * this.approachScale + 1;
        hit.approach.scale.set(0.5 * this.hitSpriteScale * scalemul);
    } else {
        hit.approach.scale.set(0.5 * this.hitSpriteScale);
    }
    if (diff <= this.approachTime && diff > approachFullAppear) { 
        hit.approach.alpha = (this.approachTime - diff) / this.approachFadeInTime;
    }
    else if (diff <= approachFullAppear && hit.score<0) { 
        hit.approach.alpha = 1;
    }
    // Calculate the opacity of the circle
    let noteFullAppear = this.approachTime -hit.objectFadeInTime; 
    function setcircleAlpha(alpha) {
        hit.base.alpha = alpha;
        hit.circle.alpha = alpha;
        for (let i=0; i<hit.numbers.length; ++i)
            hit.numbers[i].alpha = alpha;
        hit.glow.alpha = alpha * self.glowMaxOpacity;
    }
    if (diff <= this.approachTime && diff > noteFullAppear) { 
        let alpha = (this.approachTime - diff) /hit.objectFadeInTime;
        setcircleAlpha(alpha);
    }
    else if (diff <= noteFullAppear) {
        if (-diff > hit.objectFadeOutOffset) { 
            let timeAfter = -diff - hit.objectFadeOutOffset;
            setcircleAlpha(clamp01(1 - timeAfter / hit.circleFadeOutTime));
            hit.approach.alpha = clamp01(1 - timeAfter / 50);
        }
        else {
            setcircleAlpha(1);
        }
    }
    // Flash out if clicked
if (hit.score > 0 && hit.enableflash) {
    hit.burst.visible = true;
    let timeAfter = time - hit.clickTime;
    let t = timeAfter / this.glowFadeOutTime;
    let newscale = 1 + 0.5 * t * (2-t);
    hit.burst.scale.set(newscale * hit.burst.initialscale);
    hit.glow.scale.set(newscale * hit.glow.initialscale);
    hit.burst.alpha = this.flashMaxOpacity * clamp01((timeAfter < this.flashFadeInTime)? (timeAfter / this.flashFadeInTime): (1 - (timeAfter - this.flashFadeInTime) / this.flashFadeOutTime));
    hit.glow.alpha = clamp01(1 - timeAfter / this.glowFadeOutTime) * this.glowMaxOpacity;
    
    if (hit.base.visible) {
        if (timeAfter < this.flashFadeInTime) {
            hit.base.scale.set(newscale * hit.base.initialscale);
            hit.circle.scale.set(newscale * hit.circle.initialscale);
            for (let i=0; i<hit.numbers.length; ++i)
                hit.numbers[i].scale.set(newscale * hit.numbers[i].initialscale);
        }
        else {
            // hide circle
            hit.base.visible = false;
            hit.circle.visible = false;
            for (let i=0; i<hit.numbers.length; ++i)
                hit.numbers[i].visible = false;
            hit.approach.visible = false;
        }
    }
}
this.updateJudgement(hit.judgements[0], time);
}

// Define a function to update a slider
this.updateSlider = function(hit, time) {
    // Update the hit circle part of the slider
    this.updateHitCircle(hit, time);

    let noteFullAppear = this.approachTime - hit.objectFadeInTime; 

    hit.body.startt = 0.0;
    hit.body.endt = 1.0;

    // Set the opacity of the slider body
    function setbodyAlpha(alpha) {
        hit.body.alpha = alpha;
        for (let i=0; i<hit.ticks.length; ++i)
            hit.ticks[i].alpha = alpha;
    }
    let diff = hit.time - time; 
    if (diff <= this.approachTime && diff > noteFullAppear) {
        // Fade in (before hit)
        setbodyAlpha((this.approachTime - diff) / hit.objectFadeInTime);
        if (hit.reverse) hit.reverse.alpha = hit.body.alpha;
        if (hit.reverse_b) hit.reverse_b.alpha = hit.body.alpha;
    } else if (diff <= noteFullAppear) {
        if (-diff > hit.fadeOutOffset) {
            let t = clamp01((-diff - hit.fadeOutOffset) / hit.fadeOutDuration);
            setbodyAlpha(1-t*(2-t));
        }
        else {
            setbodyAlpha(1);
            if (hit.reverse) hit.reverse.alpha = 1;
            if (hit.reverse_b) hit.reverse_b.alpha = 1;
        }
    }
    // Update the slider body's start and end times
    if (this.game.snakein) {
        if (diff > 0) {
            let t = clamp01((time - (hit.time - this.approachTime)) / (this.approachTime / 3));
            hit.body.endt = t;
            if (hit.reverse) {
                let p = hit.curve.pointAt(t);
                hit.reverse.x = p.x;
                hit.reverse.y = p.y;
                let p2;
                if (t < 0.5) {
                    let p2 = hit.curve.pointAt(t+0.005);
                    hit.reverse.rotation = Math.atan2(p.y - p2.y, p.x - p2.x);
                } else {
                    let p2 = hit.curve.pointAt(t-0.005);
                    hit.reverse.rotation = Math.atan2(p2.y - p.y, p2.x - p.x);
                }
            }
        }
    }
}

// Define a function to resize the follow circle
function resizeFollow(hit, time, dir) {
    // If the follow circle's last time is not set, set it to the current time
    if (!hit.followLasttime) hit.followLasttime = time;
    // If the follow circle's linear size is not set, set it to 1
    if (!hit.followLinearSize) hit.followLinearSize = 1;
    // Calculate the time difference between the current time and the last time
    let dt = time - hit.followLasttime;
    // Update the follow circle's linear size based on the direction and time difference
    hit.followLinearSize = Math.max(1, Math.min(2, hit.followLinearSize + dt * dir));
    // Update the follow circle's size based on the linear size
    hit.followSize = hit.followLinearSize; 
    // Update the follow circle's last time to the current time
    hit.followLasttime = time;
}

// Update the slider's position and animation
if (-diff >= 0 && -diff <= hit.fadeOutDuration + hit.sliderTimeTotal) { 
    // Calculate the position relative to the slider duration
    let t = -diff / hit.sliderTime;
    // Update the current repeat count
    hit.currentRepeat = Math.min(Math.ceil(t), hit.repeat);
    // Check if the slider edge has been hit
    let atEnd = false;
    if (Math.floor(t) > hit.lastrep)
    {
        hit.lastrep = Math.floor(t);
        if (hit.lastrep > 0 && hit.lastrep <= hit.repeat)
            atEnd = true;
    }
    // Clamp the position to the slider duration
    t = repeatclamp(Math.min(t, hit.repeat));

    // Update the ball and follow circle position
    let at = hit.curve.pointAt(t);

    hit.follow.x = at.x;
    hit.follow.y = at.y;
    hit.ball.x = at.x;
    hit.ball.y = at.y;

    // Update the hit circle position if it is visible and not hit
    if (hit.base.visible && hit.score<=0) {
        hit.base.x = at.x;
        hit.base.y = at.y;
        hit.circle.x = at.x;
        hit.circle.y = at.y;
        for (let i=0; i<hit.numbers.length; ++i) {
            hit.numbers[i].x = at.x;
            hit.numbers[i].y = at.y;
        }
        hit.glow.x = at.x;
        hit.glow.y = at.y;
        hit.burst.x = at.x;
        hit.burst.y = at.y;
        hit.approach.x = at.x;
        hit.approach.y = at.y;
    }

    // Calculate the distance between the mouse position and the ball position
    let dx = game.mouseX - at.x;
    let dy = game.mouseY - at.y;
    // Calculate the follow circle's pixel size
    let followPixelSize = hit.followSize * this.circleRadius;
    // Check if the mouse is following the ball
    let isfollowing = dx*dx + dy*dy <= followPixelSize * followPixelSize;
    // Predict the mouse position
    let predict = game.mouse(this.realtime);
    // Calculate the distance between the predicted mouse position and the ball position
    let dx1 = predict.x - at.x;
    let dy1 = predict.y - at.y;
    // Check if the predicted mouse position is following the ball
    isfollowing |= dx1*dx1 + dy1*dy1 <= (followPixelSize + predict.r) * (followPixelSize + predict.r);
    // Check if the slider is activated
    let activated = this.game.down && isfollowing || hit.followSize > 1.01;

    // Update the slider tick judgement
    if (hit.nexttick < hit.ticks.length && time >= hit.ticks[hit.nexttick].time) {
        if (activated) {
            hit.ticks[hit.nexttick].result = true;
            self.playTicksound(hit, hit.ticks[hit.nexttick].time);
            // Special rule: only missing slider end will not result in a miss
            hit.judgements[hit.judgements.length-1].defaultScore = 50;
        }
        self.scoreOverlay.hit(activated?10:0, 10, time);
        hit.nexttick++;
    }

    // Update the slider edge judgement
    if (atEnd && activated) {
        self.invokeJudgement(hit.judgements[hit.lastrep], 300, time);
        self.scoreOverlay.hit(300, 300, time);
        self.playHitsound(hit, hit.lastrep, hit.time + hit.lastrep * hit.sliderTime);
    }

    // Update the slider ball and follow circle animation
    if (-diff >= 0 && -diff <= hit.sliderTimeTotal) {
        // Slider ball immediately emerges
        hit.ball.visible = true;
        hit.ball.alpha = 1;
        // Follow circle immediately emerges and gradually enlarges
        hit.follow.visible = true;
        if (this.game.down && isfollowing)
            resizeFollow(hit, time, 1 / this.followZoomInTime); 
        else
            resizeFollow(hit, time, -1 / this.followZoomInTime); 
        let followscale = hit.followSize * 0.45 * this.hitSpriteScale;
        hit.follow.scale.x = hit.follow.scale.y = followscale;
        hit.follow.alpha = hit.followSize - 1;
    }
    let timeAfter = -diff - hit.sliderTimeTotal;
    if (timeAfter > 0) {
        resizeFollow(hit, time, -1 / this.followZoomInTime); 
        let followscale = hit.followSize * 0.45 * this.hitSpriteScale;
        hit.follow.scale.x = hit.follow.scale.y = followscale;
        hit.follow.alpha = hit.followSize - 1;
        hit.ball.alpha = this.fadeOutEasing(timeAfter / this.ballFadeOutTime);
        let ballscale = (1 + 0.15 * timeAfter / this.ballFadeOutTime) * 0.5 * this.hitSpriteScale;
        hit.ball.scale.x = hit.ball.scale.y = ballscale;
    }

    // Update the reverse arrow
    if (hit.repeat > 1) {
        let finalrepfromA = hit.repeat - hit.repeat % 2; 
        let finalrepfromB = hit.repeat-1 + hit.repeat % 2; 
        hit.reverse.visible = (hit.currentRepeat < finalrepfromA);
        if (hit.reverse_b)
            hit.reverse_b.visible = (hit.currentRepeat < finalrepfromB);
        // TODO reverse arrow fade out animation
    }

    // Update the snaking out portion
if (this.game.snakeout) {
    if (hit.currentRepeat == hit.repeat) {
        if (hit.repeat%2==1) {
            hit.body.startt = t;
            hit.body.endt = 1.0;
        }
        else {
            hit.body.startt = 0.0;
            hit.body.endt = t;
        }
    }
}

// Calculate the ticks fade in/out
for (let i=0; i<hit.ticks.length; ++i) {
    if (time < hit.ticks[i].appeartime) { 
        let dt = hit.ticks[i].appeartime - time;
        hit.ticks[i].alpha *= clamp01(1-dt/500);
        hit.ticks[i].scale.set(0.5 * this.hitSpriteScale * (0.5 + 0.5 * clamp01((1-dt/500)*(1+dt/500))));
    }
    else {
        hit.ticks[i].scale.set(0.5 * this.hitSpriteScale);
    }
    if (time >= hit.ticks[i].time) {
        let dt = time - hit.ticks[i].time;
        if (hit.ticks[i].result) { 
            hit.ticks[i].alpha *= clamp01(-Math.pow(dt/150-1,5));
            hit.ticks[i].scale.set(0.5 * this.hitSpriteScale * (1+0.5*(dt/150)*(2-dt/150)));
        }
        else { 
            hit.ticks[i].alpha *= clamp01(1-dt/150);
            hit.ticks[i].tint = colorLerp(0xffffff, 0xff0000, clamp01(dt/75));
        }
    }
}

// Display the hit score
for (let i=0; i<hit.judgements.length; ++i)
    this.updateJudgement(hit.judgements[i], time);
}

// Define a function to update a spinner
this.updateSpinner = function(hit, time) {
    // Update the rotation
    if (time >= hit.time && time <= hit.endTime) {
        if (this.game.down) {
            let Xr = this.game.mouseX - hit.x;
            let Yr = this.game.mouseY - hit.y;
            let mouseAngle = Math.atan2(Yr, Xr);
            if (!hit.clicked) {
                hit.clicked = true;
            }
            else {
                let delta = mouseAngle - hit.lastAngle;
                if (delta > Math.PI) delta -= Math.PI * 2;
                if (delta < -Math.PI) delta += Math.PI * 2;
                hit.rotation += delta;
                hit.rotationProgress += Math.abs(delta);
            }
            hit.lastAngle = mouseAngle;
        }
        else {
            hit.clicked = false;
        }
    }
}

// Define a function to update the spinner
this.updateSpinner = function(hit, time) {
    // Calculate the opacity of the spinner
    let alpha = 0;
    if (time >= hit.time - self.spinnerZoomInTime - self.spinnerAppearTime)
    {
        if (time <= hit.endTime)
            alpha = 1;
        else
            alpha = clamp01(1 - (time - hit.endTime) / self.spinnerFadeOutTime);
    }
    // Set the opacity of the spinner components
    hit.top.alpha = alpha;
    hit.progress.alpha = alpha;
    hit.base.alpha = alpha;

    // Calculate the scales of the spinner components
    if (time < hit.endTime) {
        // Top zoom in first
        hit.top.scale.set(0.3 * clamp01((time - (hit.time - self.spinnerZoomInTime - self.spinnerAppearTime)) / self.spinnerZoomInTime));
        hit.base.scale.set(0.6 * clamp01((time - (hit.time - self.spinnerZoomInTime)) / self.spinnerZoomInTime));
    }
    if (time < hit.time) {
        let t = (hit.time - time) / (self.spinnerZoomInTime + self.spinnerAppearTime);
        if (t <= 1)
            hit.top.rotation = -t*t*10;
    }
    // Calculate the progress of the spinner
    let progress = hit.rotationProgress / hit.rotationRequired;
    if (time > hit.time) {
        // Update the rotation of the spinner components
        hit.base.rotation = hit.rotation / 2;
        hit.top.rotation = hit.rotation / 2;
        // Update the scale of the progress component
        hit.progress.scale.set(0.6 * (0.13 + 0.87 * clamp01(progress)));
    }
    else {
        // Hide the progress component
        hit.progress.scale.set(0);
    }

    // Check if the spinner has ended
    if (time >= hit.endTime) {
        // Check if the spinner has not been hit
        if (hit.score < 0) {
            // Calculate the score based on the progress
            let points = 0;
            if (progress >= 1) points = 300; else
            if (progress >= 0.9) points = 100; else
            if (progress >= 0.75) points = 50;
            // Update the hit success
            this.hitSuccess(hit, points, hit.endTime);
        }
    }
    // Update the judgement
    this.updateJudgement(hit.judgements[0], time);
}

// Define a function to update the hit objects
this.updateHitObjects = function(time) {
    // Update the upcoming hits
    self.updateUpcoming(time);
    // Update each hit object
    for (var i = self.upcomingHits.length - 1; i >= 0; i--) {
        var hit = self.upcomingHits[i];
        // Update the hit object based on its type
        switch (hit.type) {
            case "circle":
                self.updateHitCircle(hit, time);
                break;
            case "slider":
                self.updateSlider(hit, time);
                break;
            case "spinner":
                self.updateSpinner(hit, time);
                break;
        }
    }
}

// Define a function to update the background
this.updateBackground = function(time) {
    // Check if the background exists
    if (!self.background) return;
    // Calculate the fade value
    let fade = self.game.backgroundDimRate;
    // Check if the time is before the wait time
    if (time < -self.wait)
        fade *= Math.max(0, 1 - (-self.wait - time) / self.backgroundFadeTime);
    // Set the tint of the background
    self.background.tint = colorLerp(0xffffff, 0, fade);
}

// Define a function to render the game
this.render = function(timestamp) {
    // Update the real time
    this.realtime = new Date().getTime();
    // Update the frame interval
    if (window.lastPlaybackRenderTime) {
        window.currentFrameInterval = this.realtime - window.lastPlaybackRenderTime;
    }
    window.lastPlaybackRenderTime = this.realtime;

    // Get the current time
    var time;
    if (this.audioReady) {
        time = osu.audio.getPosition() * 1000 + self.offset;
    }
    // Check if the time is defined
    if (typeof time !== 'undefined') {
        // Update the break overlay
        let nextapproachtime = (waitinghitid < this.hits.length && this.hits[waitinghitid].time - (this.hits[waitinghitid].approachTime || this.approachTime) > time)? this.hits[waitinghitid].time - (this.hits[waitinghitid].approachTime || this.approachTime): -1;
        this.breakOverlay.countdown(nextapproachtime, time);
        // Update the background
        this.updateBackground(time);
        // Update the hit objects
        this.updateHitObjects(time);
        // Update the score overlay
        this.scoreOverlay.update(time);
        // Update the game player actions
        this.game.updatePlayerActions(time);
        // Update the progress overlay
        this.progressOverlay.update(time);
        // Update the error meter
        this.errorMeter.update(time);
    }
    else {
        // Update the background
        this.updateBackground(-100000);
    }
    // Update the volume menu
    this.volumeMenu.update(timestamp);
    // Update the loading menu
    this.loadingMenu.update(timestamp);
    // Update the cursor predict visualizer
    // this.updateCursorPredictVisualizer();

    // Check if the game has ended
    if (time > this.endTime) {
        // Game ends
        if (!this.ended) {
            this.ended = true;
            // Pause the game
            this.pause = function(){};
            // Hide the score overlay
            this.scoreOverlay.visible = false;
            // Show the summary
            this.scoreOverlay.showSummary(this.track.metadata, this.errorMeter.record, this.retry, this.quit);
        }
        // Set the background tint to white
        self.background.tint = 0xffffff;
    }
}

// Define a function to destroy the game
this.destroy = function() {
    // Clean up
    console.log("playback:destroy");
    // Destroy each hit object
    _.each(self.hits, function(hit){
        if (!hit.destroyed) {
            // Destroy the hit object's objects and judgements
            _.each(hit.objects, function(o) { self.gamefield.removeChild(o); o.destroy(); });
            _.each(hit.judgements, function(o) { self.gamefield.removeChild(o); o.destroy(); });
            // Mark the hit object as destroyed
            hit.destroyed = true;
        }
    });
    // Destroy the score overlay
    let opt = {children: true, texture: false}
    self.scoreOverlay.destroy(opt);
    // Destroy the error meter
    self.errorMeter.destroy(opt);
    // Destroy the loading menu
    self.loadingMenu.destroy(opt);
    // Destroy the volume menu
self.volumeMenu.destroy(opt);
// Destroy the break overlay
self.breakOverlay.destroy(opt);
// Destroy the progress overlay
self.progressOverlay.destroy(opt);
// Destroy the game field
self.gamefield.destroy(opt);
// Destroy the background
self.background.destroy();
// Clean up event listeners
window.onresize = null;
window.removeEventListener("blur", blurCallback);
window.removeEventListener('wheel', wheelCallback);
window.removeEventListener('keydown', pauseKeyCallback);
window.removeEventListener('keyup', resumeKeyCallback);
window.removeEventListener('keydown', skipKeyCallback)
// Clean up player actions
self.game.cleanupPlayerActions();
// Clean up the render function
self.render = function(){};
}

// Define a function to start the game
this.start = function() {
    console.log("start playback")
    // Mark the game as started
    self.started = true;
    // Mark the game as not skipped
    self.skipped = false;
    // Set the audio gain
    self.osu.audio.gain.gain.value = self.game.musicVolume * self.game.masterVolume;
    // Set the playback rate
    self.osu.audio.playbackRate = self.playbackRate;
    // Play the audio
    self.osu.audio.play(self.backgroundFadeTime + self.wait);
}

// Define a function to retry the game
this.retry = function() {
    // Check if the game is not paused
    if (!self.game.paused) {
        // Pause the audio
        self.osu.audio.pause();
        // Mark the game as paused
        self.game.paused = true;
    }
    console.log("playback: retrying");
    // Destroy the game
    self.destroy();
    // Reconstruct the game
    self.constructor(self.game, self.osu, self.track);
    // Hide the loading menu
    self.loadingMenu.hide();
    // Mark the audio as ready
    self.audioReady = true;
    // Start the game
    self.start();
}

// Define a function to quit the game
this.quit = function() {
    // Check if the game is not paused
    if (!self.game.paused) {
        // Pause the audio
        self.osu.audio.pause();
        // Mark the game as paused
        self.game.paused = true;
    }
    console.log("playback: quiting");
    // Destroy the game
    self.destroy();
    // Quit the game
    if (window.quitGame)
        window.quitGame();
}

// Define a function to skip the game
this.skip = function() {
    // Check if the audio can be skipped
    if (self.osu.audio && self.osu.audio.seekforward(self.skipTime) {
        // Mark the game as skipped
        self.skipped = true;
            }
        }
    }
    
    return Playback;
});